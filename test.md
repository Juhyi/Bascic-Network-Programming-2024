### 네트워크 프로그래밍, 소켓 
- 소켓이란?
    - 물리적으로 연결된 네크워크 상에서의 데이터 송수신에 사용할 수 있는 소프트웨어적인 장치로,
    - 소켓을 이용하여 데이터를 주고 받을 수 있다.(네트워크 프로그래밍을 소켓 프로그래밍이라고 부르는 이유)

<br>
💡즉, 소켓은 네트워크 망의 연결에 사용되는 데이터를 주고받을 있도록 해주는 도구!! 
<br>

- 소켓 구현의 구현
    
    - **핵심(server 구현을 위해 4개의 함수를 호출해야함)**
     소 | 소켓(socket) - 휴대폰 구입 | 소켓 생성
     말 | 바인드 (bind) - 전화번호 할당 | IP주소와 PORT번호 할당
     리 | 리슨 (listen) - 개통 | 연결요청 가능상태로 변경
     아 | 엑셉트 (accept) - 전화를 받음. ㅣ (연결 요청에 대한 수락)

<br>

#### 💡 소켓을 전화기라고 생각하고 이해하면 편하다. 전화를 하려면 첫번째로 전화기가 필요하닌깐 전화기를 구입해야 한다. 즉 소켓을 생성해야하는 것!

( 소켓은 전화를 거는 소켓 (이걸 서버소켓이라고함)과 전화를 받는 소켓(클라이언트 소켓)의 생성 방법이 다르다. 서버소켓에 비해 클라이언트 소켓의 생성은 간단하기 때문에 이 페이지에서는 서버소켓의 생성에 대해 다룸. )
<br>
***

- 첫번째 함수 
    - 소켓의 생성에 해당하는 함수 - socket()
        ```C
        #include <sys/socket.h>
        int socket(int domain, int type, int protocol);
        ```  
    - [인자]
        - domain : domain은 프로토콜의 family를 지정해준다.  프로토콜의 family를 지정해준다는 것은 어떤 영역에서 통신할 것인지에 대한 영역을 지정해준다는 말이다. 
            - 입력값은 AF_UNIX(프로토콜 내부에서), AF_INET(IPv_4), AF_INET6(IPv6) 이 있다. 일반적으로 우리가 공부하면서 사용하는 것은 AF_INET이다.

        - type : type은 어떤 타입의 프로토콜을 사용할 것인지에 대한 설정이다.
            - 입력값은 SOCK_STREAM(TCP), AF_DGFAM(UDP), SOCK_RAM(사용자 정의)가 있다. 이것에 대한 자세한 설명은 뒤에서 다시 나온다.

        - ptorocol : ptorocol은 어떤 프로토콜의 값을 결정하는 것이다.
            - 대부분 0을 사용한다. 그 외의 경우에는 IPROTO_TCP, IPPROTO_UDP가 있다 이것에 대한 자세한 설명도 뒤에서 한다.

    - [반환]
        - socket() 함수 호출을 성공하면 해당 소켓을 가리는 소켓 디스크립터(sock descriptor)를 반환해준다. 소켓 디스크립터는 운영체제가 특정 파일에 할당해준 정수값을 의미한다. 0 이상의 값을 반환하며 생성에 실패하면 -1을 반환한다.
*** 
<br>

#### 💡 소켓의 생성을 전화기 구입에 비유했다. 전화기를 구입하고 나면 바로 전화를 할 수 있을까? 아니다. 누군가에게 전화를 하려면 전화번호가 필요하다. 전화번호가 없다면 전화기가 있어도 연락을 할 방법이 없다.  그럼 전화번호를 어떻게 부여 받을까?

bind() 함수가 바로 전화번호를 부여하는 함수이다!
소켓에서 전화번호를 의미하는 것은 소켓의 주소정보인 IP주소와 port번호를 말한다!!
<br>
***

- 두번째 함수 
    - 소켓에 주소를 할당하는 함수 - bind()
        ```C
        //성공하면 0, 실패하면 -1을 반환한다.
        #include <sys/socket.h>
        int bind(int sockfd, struct sockaddr *addr, socklen_t addrlen);
        ```
   bind()는 3가지 인자를 통해 socket() 함수로 받아온 디스크립터 sockfd 파일에 해당하는 소켓에 serv_addr 주소를 할당한다!!

    - [인자]
        - sockfd : socket()함수를 통해 배정받은 디스크립터 번호 serv_sock에 해당한다. 주소를 할당할 소켓!

        - *addr :IP주소텍스트와 PORT번호를 지정한 serv_addr 구조체. (이 구조체는 후에 다룸.)

        - addrlen : 주소정보를 담은 변수의 길이
***
<br>

#### 💡 이제 전화기로 전화를 걸 번호도 가졌다! 그럼 이제 개통을 하여 실제로 연락이 가능하도록 만들어야 한다! 개통을 소켓에서는 연결요청이 가능한 상태로 만드는 것으로 생각하면 된다. 이 연결요청이 가능한 상태로 만드는 함수가 listen() 함수이다!
<br>

*** 
- 세번째 호출함수
    - 연결 요청을 대기하는 함수 - listen()
    ```C
    // 성공하면 0, 실패하면 -1을 반환한다.
    #include <sys/socket.h>
    int listen(int sock, int backlog);
    ```
    - [인자]
        - sock : 소켓 디스크립터 번호
        - backlog : 연결요청을 대기하는 큐의 크기
        
    - 이렇게 지정한 소켓이 리스닝 소켓이 되고, backlog만큼의 큐 공간을 가지게 된다. 
***
<br>

#### 💡 개통을 마쳤으면 드디어 전화가 가능해진다! 전화의 벨이 울리면 통화 버튼을 눌러 전화를 하면 된다! 통화 버튼을 누른다는 것은 연결요청의 수락을 의미한다. accept()함수 호출이 요청을 수락하는 행위를 의미한다
<br>
*** 

- 네번째 호출함수
    - 연결 요청을 수락하는 함수 - accept()

    ```C
    // 성공 시 디스크립트 번호, 실패 시 -1 반환
    #include <sys/socket.h>
    int accept(int sock, struct sockaddr*addr, socklen_t *addrlen);
    ```
    - accept() 함수는 대기중인 클라이언트의 요청을 차례로 수락하여 데이터를 주고 받을 수 있게 해준다.

    - [인자]
        - sock : 서버소켓(리스닝 소켓)의 디스크립터 번호
        - addr : 대기 큐를 참조해 얻은 클라이언트의 주소 정보

    - [반환]
    함수 호출에 성공하면 새로운 디스크립트 번호를 반환하는데 accept함수 전까지 이용하던 소켓은 리스닝소켓(서버소켓)으로 연결요청을 대기시키는 과정까지만 담당한다. accept() 호출 성공 이후에는 새로 할당받은 소켓을 이용해 데이터를 송수신한다!!
***    
<br>


 ### 🌟🌟 지금까지의 내용으로 네트워크 프로그래밍에서 연결요청을 허용하는 소켓의 구현을 할 수 있다!! 다음 글은 실제 서버 프로그램을 구현하기 위해 위의 함수를 사용하는 실습에 대해 다루겠다 :) 🌟🌟



