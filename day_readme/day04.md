## 4일차 (2024-06-14)
- 좀비 프로세스 소멸
    - 1. wait() 함수 사용 
    
        ```C
        #include <sys/wait.h>
        pid_t wait(int * statloc);
        ```
        - 반환 : 성공 시 종료된 자식 프로세스의 ID, 실패 시 -1
        - WIFEXITED : 자식 프로세스가 정상 종료한 경우 true 반환
        - WEXITSTATUS : 자식 프로세스의 전달 값 반환
        - wait 함수는 자식 프로세스가 종료되지 않은 상황에서는 반환하지 않고 블로킹 상태에 놓임 -> 이걸 해결한 것이 waitpid() 함수
    
    - 2. waitpid() 함수 사용

        ```C
        #include <sys/wait.h>
        pid_t waitpid(pid_t pid, int * statloc int options);
        ```
        - 반환 : 성공 시 종료된 자식 프로세스의 ID(or 0), 실패 시 -1 반환
        - 매개변수 1. pid - 종료를 확인하고자 하는 자식 프로세스의 ID 전달. ID 대신에 -1을 전달하면 wait함수와 마찬가지로 동작(블로킹 상태)
        - 매개변수 2. statloc - wait 함수의 매개변수와 동일.
        - 매개변수 3. option - 헤더파일 sys/wait.h에 선언된 상수 WINOHANG을 인자로 전달하면, 종료된 자식 프로세스가 존재하지 않아도 블로킹 상태에 있지 않음 -> 0을 반환하면서 함수 탈출.
        - 즉, 블로킹 상태에 놓이지 않게 할수 있는 함수!

- 시그널 핸들링
    - 부모 프로세스가 자식프로세스의 종료를 기다리면서 waitpid 함수만 호출할 수 없기 때문에 운영체제 (자식프로세스 종료를 인식하는 것은 운영체제 이므로)가 시그널을 주면 이런 문제를 해결할 수 있음. 이런 프로그램의 구현을 위해서 시그널 핸들링이 존재.
    
    - 시그널 : 특정 상황이 되면 운영체제가 프로세스에게 해당 상황이 발생했다는 것을 알리는 메세지
    - 시그널 핸들링 : 그 메시지에 반으애서 메시지와 연관된 미리 정의된 작업이 진행되는 것.
    - 시그널 등록 :
        -  특정 상황에서 운영체제로부터 프로세스가 시그널을 받기 위해선 해당 상황에 대해 등록의 과정을 거쳐야한다.
        - 즉, 프로게스는 자식 프로세스의 종료라는 상황 발생시, 특정 상황 발생시, 특정 함수의 호출을 운영체제에게 요구하는 것 -> 시그널 등록 함수의 호출을 통해 이루어짐. 
        
    - 시그널 등록 함수 
        ``` C
        #include <signal.h>
        void (*signal(int signo, void(*func)(int)))(int);
        ```
        - 반환 : 이전에 등록된 함수의 포인터
        - 매개변수 1. signo는 특정상황에 대한 정보를 전달
        - 매개변수 2. (*func)(int) 는 특정 상황에서 호출될 함수의 주소값(포인터)을 전달.
        - signal 함수를 통해 등록 가능한 상황, 상황에 할당된 상수
            - SIGALRM : alarm 함수 호출을 통해서 등록된 시간이 된 상황
            - SIGINT : CTRL+C가 입력된 상황
            - SIGCHLD : 자식 프로세스가 종료된 상황

        - 예제의 alarm () 함수
            ```C
            #include <unistd.h>
            unsigned int alarm(sunsigned int seconds);
            ```
            - 반환 : 0 | SIGALRM 시그널이 발생하기까지 남은있는 시간(초단위)

    - sigaction ()
        - signal함수를 대채할 수 있고 운영체제에 대한 동작방식에 차이가 없어 signal함수보다 훨씬 안정적으로 동작.  
        ```C
        #include <unistd.h>
        int sigaction(int signo, const struct sigaction * act, struct sigaction * oldact);    
        ```

        - 반환 : 성공 시 0, 실패 시 -1
        - 매개변수 1. signal 함수와 동일
        - 매개변수 2. act는 첫번째 인자로 전달된 상수에 해당하는 시그널 발생시 호출될 함수(시그널 핸드러)의 정보 전달
        - 매개변수 3. oldact는 이전에 등록되었던 시그널 핸들러의 함수 포인터를 얻는데 사용되는 인자, 필요없으면 0 전달.

        - 함수 호출을 위해서는 sigaction의 구조체 변수를 선언하고 초기화 해야함.
        ```C
        {
            void(*sa_handler)(int); // 시그널 헨들러의 함수 포인터 값
            sigset_t sa_mask;   // 모든 비트를 ㅐ으로
            int sa_flags;   // 0으로 초기화
        }

- 시그널 핸들리을 통한 좀비 프로세스 소멸
    - 예제 실습
    
    ![좀비 프로세스 소멸](https://raw.githubusercontent.com/Juhyi/Bascic-Network-Programming-2024/main/imges/net008.png)

***
- 멀티태스킹 기반 다중 접속

- 다중접속 서버의 구현
    - [프로세스 기반의 다중접속 서버모델]
        
        
        ![프로세스 기반의 다중접속 서버모델](https://raw.githubusercontent.com/Juhyi/Bascic-Network-Programming-2024/main/imges/net005.png)

    - 1단계 - 에코서버(부모 프로세스)는 accept 함수호출을 통해서 연결요청을 수락
    - 2단계 - 이때 얻게 되는 소켓의 파일 디스크립터를 자식 프로세스를 생성해서 넘겨준다.
    - 3단계 - 자식 프로세스는 전달받은 파일 디스크립터를 바탕으로 서비스를 제공

    - **핵심은 연결이 하나 생성될 때마다 프로세스를 생성해서 해당 클라이언트에 대해 서비스를 제공한다는 것!**
    
    - 예제 실습
    [서버 실행화면] 


         ![서버 실행화면](https://raw.githubusercontent.com/Juhyi/Bascic-Network-Programming-2024/main/imges/net006.png)


     [클라이언트 실행화면] 


         ![클라이언트 실행화면](https://raw.githubusercontent.com/Juhyi/Bascic-Network-Programming-2024/main/imges/net007.png)



- fork 함수호출을 통한 파일 디스크립터의 복사
    - 프로세스가 복사되는 경우 해당 프로세스에 의해 만들어진 소켓이 아니라 파일 디스크립터가 복사되는 것!
    - 소켓은 프로세스의 소유가 아니라 운영체제의 소유, 소켓을 의미하는 파일 디스크립터만 프로세스의 소유다.
    - 만약, 소켓이 복사된다면 port에 할당된 소켓이 2개가 된다는 것 -> 하나의 운영체제 내에서는 동일한 PORT 번호를 둘 이상의 소켓에게 할당할 수 없기때문에 말이 안됨
    - 하나의 소켓에 두개의 파일 디스크립트가 존재하는 경우 -> 두 파일 디스크립터 모두 종료되어야 해당 소켓이 소멸하기 때문에 fork 함수호출 후에는 서로에게 상관없는 디스크립터를 종료한다. 


    ![복사된 파일 디스크립터 정리](https://raw.githubusercontent.com/Juhyi/Bascic-Network-Programming-2024/main/imges/net9.png)


- TCP의 입출력 루틴(Routine) 분할
    - 이점
        - 소켓은 양방향 통신이 가능하기 때문에 입력을 담당하는 프로세스와 출력을 담당하는 프로세스를 각각 생성하면, 입력과 출력을 별도로 진행할 수 있다
        - 입출력 루틴을 분할하면 보내고 받는 구조가 아니라 둘을 동시에 진행할 수 있음.

***
- 프로세스간 통신
    - 두 프로세스 사이에서의 데이터 전달
    - 두 프로세스 사이에서의 데이터 전달이 가능하려면, 두 프로세스가 함께 공유하는 메모리가 존재해야함.

- 프로세스간 통신의 어려움
    - 모든 프로세스는 자신만의 메모리 공간을 독립적으로 구성함. (부모,자식 프로세스 또한 독립적임)
    - 따라서 운영체제가 별도의 메모리 공간을 마련해줘야만 프로세스간 통신이 가능하다.

- 파이프(PIPE) 기반의 프로세스간 통신
    - 파이프는 소켓과 마찬가지로 운영체제에 속하는 자원. (그렇기 때문에 fork 함수의 호출에 의한 복사 대상이 아님.)
    - 운영체제가 마련해준 메모리 공간을 통해서 두 프로세스는 통신을 할 수 있음
    
    - 파이프 생성 함수
        ```C
        #include <unistd.h>
        int pipe(int filedes[2]);
        ```
        - 반환 : 성공 시 0, 실패 시 1
        - filedes[0] - 데이터 수신하는데 사용되는 파일 디스크립터가 저장됨. 파이프의 출구
        - filedes[1] - 데이터 전송하는데 사용되는 파일 디스크립터가 저장됨. 파이프의 입구
        - 함수가 호출되면, 운영체제는 서로 다른 프로세스가 함꼐 접근할 수 있는 메모리 공간을 생성, 접근에 사용되는 파일 디스크립터를 반환.
    
    - pipe1.c 예제 (단방향 통신)

        ![pipe 통신경로](https://raw.githubusercontent.com/Juhyi/Bascic-Network-Programming-2024/main/imges/net10.png)

        - 자식은 입력 경로에만 부모는 출력 경로에만 접근해서 통신을 했음.
    
    - 파이프 기반의 프로세스간 양방향 통신
        - 양방향 통신을 위해서는 두 개의 파이프를 생성해야한다. 그래야 입출력의 타이밍에 따라서 데이터의 흐름이 방해받지 않기 때문에.
    
    - 메시지를 저장하는 에코 서버 예제 실습
        - 둘 이사의 클라이언트를 접속시켜 서버로 문자열을 전송하면 문자열이 파일에 저장됨.
        - 생성된 txt 파일을 열어 문자열 저장을 확인할 수 있다.

***

- IO 멀티플렉싱(Multiplexing)
    - 멀티 프로세스 서버의 대안으로 하나의 프로세스가 다수의 클라이언트에게 서비스를 할 수 있도록 한다.
    - 하나의 프로세스가 여러 개의 소켓을 핸들링 할 수 있는 방법 

- select 함수
    - 기능
        - select 함수를 이용하면, 배열에 저장된 다수의 파일 디스크립터를 대상으로 3가지 질문을 던진다.
            1. 수신할 데이터를 지니고 있는 소켓이 존재하는가?
            2. 블로킹되지 않고 데이터의 전송이 가능한 소케은 무엇인가?
            3. 예외상황이 발생한 소켓은 무엇인가?
    - 호출방법과 순서
        1. [파일 디스크립터의 설정][검사의 범위 지정][타임아웃의 설정] - 관찰의 대상을 묶고, 관찰의 유형을 지정
        2. [select함수 호출] - 관찰 대상의 변화를 물음.
        3. [호출 결과 확인] - 물음에 대한 답을 듣는다.
        - 파일 디스크립터의 설정
            - fd_set형 변수에 select 함수에 전달할 디스크립트의 정보를 묶음
            - fd_set형 변수는 비트단위로 이뤄진 배열.
            - 각 인덱스의 비트가 1로 설정되면 그 인덱스에 해당하는 파일 디스크립터는 관찰대상이 되는 것이고, 0이면 관찰대상에서 제외
            ```C
            FD_ZERO(fd_set * fdset)  : fdset의 모든 비트를 0으로 초기화

            FD_SET(int fd, fd_set *fdset) : fdset에 fd 파일디스크립터 정보를 등록

            FD_CLR(int fd, fd_set *fdset) : fdset에 fd 파일디스크립터 정보를 제거

            FD_ISSET(int fd, fd_set *fdset) : fdset에 fd 파일디스크립터 정보가 있으면 양수를 반환
            ```
        - 검사 범위 지정
            - 관찰대상이 되는 파일 디스크립터의 개수, 0부터 시작해서 생성될 때마다 1씩 증가하기 때문에 가장 큰 파일 디스크립터의 값에 1을 더해주면 됨.
        - 타임아웃 설정
            - timeval : select함수의 인자에 들어가는 구조체, 타임아웃을 설정하고 싶지 않을때는 NULL을 인자로 전달.
    - select 함수
    ```C
    #include<sys/select.h>
    #include<sys/time.h>

    int select(int maxfd, fd_set *readset, fd_set *writeset, 
                fd_set *exceptset, const struct timeval * timeout);
    ```

- 멀티플렉싱 서버의 구현 
    - 예제 실습
