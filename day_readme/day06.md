## 6일차
- epoll의 이해
    - select 기반 IO 멀티플렉싱이 느린 이유
        1. select 함수 호출 이후에 항상 등장하는, 모든 디스크립터를 대상으로 하는 반복문
        2. 호출할 때마다 인자로 매번 전달해야 하는 관찰대상에 대한 정보들
        - select 함수는 운영체제의 커널에 의해서 완정되는 기능이 아닌, 순수하게 함수에 의해 완성되는 기능
        - 따라서 함수의 호출을 통해서 전달된 정보는 운영체제에 등록되지 않은것이기 때문에 호출할 때마다 관련 정보를 전달해야한다. -> 단점의 가장 큰 원인

    - 해결책
        - 운영체제에게 관찰대상에 대한 정보를 딱 한번만 알려주고 관찰대상의 범위 또는 내용의 변경이 있을 때 변경 사항만 알려주도록 하자!
        - 운영체제 레벨에서 멀티플렉싱 기능을 지원해야한다는 의미.
        - 리눅스에서는 epoll, 윈도우에서는 IOCP가 그 예시이다.

    - 단점에도 사용할만한 이유
        - 서버의 접속사 수가 많지 않고 다양한 운영체제에서 운영이 가능해야 한다면 사용에 용이
        
    - epoll의 장점
        1. 상태변화의 확인을 위한, 전체 파일 디스크립터를 대상으로 하는 반복문이 필요 X
        2. select 함수에 대응하는 epoll_wait 함수호출 시, 관찰대상의 정보를 매번 전달할 필요가 X
    
- epoll의 활용
    - 구현에 필요한 함수 (3개의 함수 호출을 통해 epoll기능이 완성)
        1. epoll_create - epoll 파일 디스크립터 저장소 생성
        2. epoll_ctl - 저장소에 파일 디스크립터 등록 및 삭제
        3. epoll_wait - select 함수와 마찬가지로 파일 디스크립터의 변화를 대기
    - 구조체
        ```C
        struct epoll_event
        {
            __uint32_t events;
            epoll_data_t data;
        }
            typedef union epoll_data
            {
                void *ptr;
                int fd;
                __uint32_t u32;
                __uint64_t u64;
            } epoll_data_t;
        ```
        - 소켓 디스크립터의 등록 및 이벤트 발생의 확인에 사용되는 구조체

    - epoll_creat() 함수
        ```C
        #include <sys/epoll.h>
        int epoll_create(int size);
        ```
        - 반환 : 성공 시 epoll 파일 디스크립터, 실패 시 -1
        - 운영체제가 관리하는 epoll 인스턴스라 불리는 팡리 디스크립터의 저장소 생성
        - 소멸 시 close 함수호출을 통한 종료의 과정이 필요
        - 함수 호출로 생성된 epoll 인스턴스에 관찰대사을 저장 및 삭제하는 함수가 epoll_ctl, 이벤트의 발생 유무를 확인하는 함수가 epoll_wait이다.